<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

    <title>About Jason</title>
    <link rel="stylesheet" type="text/css" href="assets/normalize.css"/>
    <link rel="stylesheet" type="text/css" href="assets/site.css"/>
</head>

<body>
<main class="main">
    <h3>Hi, I'm Jason</h3>

    <p>
        I just started this the other day, so bear with my while I sort it out.
    </p>

    <p>
        I've been doing web applications for a long time.  <a href="https://innerjason.wordpress.com/2015/09/20/a-brief-history-of-jason/">Longer than most.</a>
        How we build web applications is changing rapidly these days.  Probably faster than it ever has.  When I started
        I mostly worked on the backend (an early Java adopter), including concurrency and deep dive performance
        analysis.  From there I got into security, information architecture, various flavors of Agile and Continuous
        Integration, Lead Devolopment and mentoring.  I still enjoy all of these kinds of work, but discovered that I
        think spatially, and that I spend a great deal of time thinking about how people think.  So it was only a matter
        of time before I started doing some UX work.
    </p>

    <img class="example" title="ScrumWorks Pro" src="assets/images/scrumworks.png"/>

    <p>
        Most of my front-end work has been in fairly densely related data, and the presentation concerns that come
        with it. When every piece of information is two degrees of separation from thousands of others, the biggest
        challenge is deciding what stays and what goes.  <em>Why</em> the person is looking at the application should
        dictate the organization of the data.  What should be front and center, and what they will drill down to see
        and what they might only care about once in a blue moon.  This requires a sense of organization, and a lot of
        thinking about thinking.
    </p>

    <h4>Full Stack</h4>

    <p>
        When I think 'Full Stack', or indeed when I'm looking for someone who labels themselves as full stack, I want
        them for one of two reasons.  On a big or complex project, I need people who can understand the entire
        application from top to bottom.  Someone who can reason about it, see failure modes and choke points to our
        success, and find concrete ways to improve the situation.  Someone who can help design the information
        flow within the system, simplifying the system and opening up new avenues for future features.  People who
        know one aspect of the problem can sit around saying that it's somebody else's responsibility to deal with it.
        A Full Stack person gets closer to the truth, and can offer multiple solutions.
    </p>
    <p>
        On a smaller project, I may not actually know what mix of skills I need for a successful project.  In this case
        my Full Stack developers are also a hedge against bottlenecks.  I value someone who's willing to expand or learn
        a skill to support the success of the entire team.  This week it might be setting up a build server.  Next it
        might be upgrading a database.  I might need extra hands to kick start a testing harness, or I might be behind on
        server side data validation.  I need someone who can either pick up a new task, or can at least help out the
        other folks by doing their own troubleshooting.
    </p>

    <p>
        I like to solve hard problems, and find ways to make the team more effective.  When I say "I'm a full stack
        developer", these are the qualities that I refer to.  I've maintained version control systems (once on my own
        dev machine), set up Continuous Integration environments and build pipelines for ten years. I've built developer
        tools, reusable libraries, instituted Process improvements, defined Code Review guidelines, established unit
        testing practices and spearheaded localization efforts.  I've built authentication frameworks, code signing
        tools, reverse proxy configurations and Docker images.  I've fixed more build scripts than I can rightly count,
        and it astounds me how consistently they possess the same set of bugs.  All these things I have done and taken
        pride in doing well.
    </p>
</main>
</body>
</html>
